#!/usr/bin/env node

const debug = require('debug')('test:server');

// to redirect HTTP connections to HTTPS
const net = require('net');
const http = require('http');
const https = require('https');
const path = require('path');

const fs = require('fs');
const uuid = require('node-uuid');
const session = require('express-session');
const cluster = require('cluster'); // for threading

// Establish secret for cookies
fs.writeFileSync(path.join(__dirname, '../config', 'cookieSecret.txt'), uuid.v4());

// Keep track of workers' statuses.
const workerStatus = {};

// Log worker generation and death
const logger = require('../services/logService');
// configuration parameters
const params = require('../config/config');

// for HTTPS server
const sslOptions = {
  key: fs.readFileSync(params.key),
  cert: fs.readFileSync(params.cert),
  requestCert: true,
  rejectUnauthorized: false
};

// Get number of cores on host, to determine how many workers to spawn
const numCPUs = require('os').cpus().length;

// Multi-threaded shared session store
const cstore = require('cluster-store');
const sessOptions = {
  sock: '/tmp/memstore.sock',

  // If left 'null' or 'undefined' this defaults to a similar memstore
  // with no special logic for 'cookie' or 'expires'
  store: cluster.isMaster && new require('express-session/session/memory')(),

  // Good default to use for instances where you might want
  // to cluster or to run standalone, but with same API
  serve: cluster.isMaster,
  connect: cluster.isWorker,
  standalone: (numCPUs === 1) // override serve and connect
};

cstore.create(sessOptions).then((store) => {
  store.get(id, (err, data) => {
    logger.write.info(data);
  });
});

process.on('unhandledPromiseRejection', (err) => {
  logger.write.warn('Unhandled Promise Rejection');
  logger.writer.error(err);

  throw err; // may generate double error message on console, but error will be written only once to error log file
});

/**
 * Event listener for HTTP server "error" event.
 * @param error thrown error
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof port === 'string'
      ? 'Pipe ' + params.baseAddress
      : 'Port ' + params.baseAddress;

  // handle specific listen errors with friendly messages
  if (error.code === 'EACCES') {
    logger.write.warn(bind + ' requires elevated privileges');
    process.exit(1);
  } else if (error.code === 'EADDRINUSE') {
    logger.write.warn(bind + ' is already in use');
    process.exit(1);
  } else {
    throw error;
  }
}

/**
 * Creates a proxy connection on the base address to redirect all HTTP requests to HTTPS
 * @param conn client connection
 */
function tcpConnection(conn) {
  // Determines whether request is HTTP or HTTPS and establishes appropriate proxy connection
  conn.once('data', (buf) => {
    // TLS handshake record starts with byte 22 --> checks if request is HTTPS
    const address = (buf[0] === 22) ? params.httpsAddress : params.redirectAddress;

    // Pipes data between server and proxy
    const proxy = net.createConnection(address, () => {
      proxy.write(buf);
      conn.pipe(proxy).pipe(conn);
    });
  });
}

/**
 * HTTP server redirects all requests to HTTPS server
 * @param req
 * @param res
 */
function httpConnection(req, res) {
  const host = req.headers.host;
  // 301 Redirect
  res.writeHead(301, { 'Location': 'https://' + host + req.url });
  res.end();
}

/**
 * Perform a function on each worker
 * @param cb callback function to perform on each worker
 */
function eachWorker(cb) {
  for (var id in cluster.workers) {
    if (cluster.workers.hasOwnProperty(id)) {
      cb(cluster.workers[id], id);
    }
  }
}

// Spawn threads, utilize all possible cores on host machine
if (cluster.isMaster) {
  // Master process forks worker processes
  for (var i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // Master process restarts dead workers
  cluster.on('exit', (worker, code, signal) => {
    const w = cluster.fork();
    // Log to file and stdout
    logger.write.worker('worker ' + worker.process.pid + ' died (' + signal || code + '). restarting...');
    w.on('message', () => {
      workerStatus[w.id] = 0;
    });
  });

  // Workers log when they start up
  cluster.on('online', (worker) => {
    // Log to file and stdout
    logger.write.worker('worker ' + worker.process.pid + ' is online');
  });

  // Workers are periodically queried to ensure they are still active. If a worker does not respond after 4 queries,
  // it is killed and a new worker is spawned.
  setInterval(() => {
    eachWorker((worker, id) => {
      if (workerStatus[id] === undefined) {
        workerStatus[id] = -1;
      }

      if (workerStatus[id] < 4) {
        workerStatus[id]++;
        worker.send('check');
      } else {
        delete workerStatus[id];
        // Log to file and stdout
        logger.writer.worker('Problem with worker ' + id);
        worker.disconnect();
        worker.kill();
      }
    });
  }, params.workerCheckInterval);

  eachWorker((worker, id) => {
    worker.on('message', () => {
      workerStatus[id] = 0;
    });
  });
} else {
  // workers can share any TCP connection

  process.on('message', (msg) => {
    process.send(msg);
  });

  const app = require('../app');
  const passport = require('../services/passportService');
  // Set up multi-threaded session store and authentication mechanism. Must be in this file for correct implementation
  // with workers
  app.use(session({
    secret: params.cookieSecret,
    name: 'LTSHelpDesk.sid',
    resave: false,
    saveUninitialized: false,
    cookie: { secure: true, httpOnly: true },
    store: cstore.store
  }));
  app.use(passport.initialize());
  app.use(passport.session());

  // onListening required three separate times due to server intialization error when extracting to independent function
  const tcpServer = net.createServer(tcpConnection).listen(params.baseAddress).on('error', onError).on('listening', function onListening() {
    const addr = tcpServer.address();
    const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
    debug('Listening on ' + bind);
  });

  const httpServer = http.createServer(httpConnection).listen(params.redirectAddress).on('error', onError).on('listening', function onListening() {
    const addr = httpServer.address();
    const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
    debug('Listening on ' + bind);
  });
  const server = https.createServer(sslOptions, app).listen(params.httpsAddress).on('error', onError).on('listening', function onListening() {
    const addr = server.address();
    const bind = typeof addr === 'string'
        ? 'pipe ' + addr
        : 'port ' + addr.port;
    debug('Listening on ' + bind);
  });
}
