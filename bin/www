#!/usr/bin/env node

// configuration parameters
const params = require('../config/config');

const https = require('https');
const path = require('path');
const fs = require('fs');
const uuid = require('node-uuid');
const session = require('express-session');
const cluster = require('cluster'); // for threading

// Establish secret for cookies
params.cookieSecret = uuid.v4();

// Keep track of workers' statuses.
const workerStatus = {};

// Log worker generation and death
const logger = require('../services/logService');

// for HTTPS server
const sslOptions = {
  key: fs.readFileSync(params.key),
  cert: fs.readFileSync(params.cert),
  requestCert: true,
  rejectUnauthorized: false,
};

// Get number of cores on host, to determine how many workers to spawn
const numCPUs = require('os').cpus().length;

// Multi-threaded shared session store
const cstore = require('cluster-store');
const sessOptions = {
  sock: '/tmp/memstore.sock',

  // If left 'null' or 'undefined' this defaults to a similar memstore
  // with no special logic for 'cookie' or 'expires'
  /* eslint-disable new-cap */
  store: cluster.isMaster && new require('express-session/session/memory')(),

  // Good default to use for instances where you might want
  // to cluster or to run standalone, but with same API
  serve: cluster.isMaster,
  connect: cluster.isWorker,
  standalone: (numCPUs === 1), // override serve and connect
};

cstore.create(sessOptions).then((store) => {
  store.get(id, (err, data) => {
    logger.write.info(data);
  });
});

process.on('unhandledPromiseRejection', (err) => {
  logger.write.warn('Unhandled Promise Rejection');
  logger.write.error(err);

  // may generate double error msg on console, but error will be written only once to error log file
  throw err;
});

/**
 * Event listener for HTTP server "error" event.
 * @param error thrown error
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof port === 'string'
      ? `Pipe ${params.baseAddress}`
      : `Port ${params.baseAddress}`;

  // handle specific listen errors with friendly messages
  if (error.code === 'EACCES') {
    logger.write.warn(`${bind} requires elevated privileges`);
    process.exit(1);
  } else if (error.code === 'EADDRINUSE') {
    logger.write.warn(`${bind} is already in use`);
    process.exit(1);
  } else {
    throw error;
  }
}

/**
 * Perform a function on each worker
 * @param cb callback function to perform on each worker
 */
function eachWorker(cb) {
  for (let id in cluster.workers) {
    if (cluster.workers.hasOwnProperty(id)) {
      cb(cluster.workers[id], id);
    }
  }
}

// Spawn threads, utilize all possible cores on host machine
if (cluster.isMaster) {
  // Master process forks worker processes
  logger.write.worker(`master ${process.pid} is online`);
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // Master process restarts dead workers
  cluster.on('exit', (worker, code, signal) => {
    const w = cluster.fork();
    // Log to file and stdout
    logger.write.worker(`worker ${worker.process.pid} died. restarting...${(signal || code)}`);
    w.on('message', () => {
      workerStatus[w.id] = 0;
    });
  });

  // Workers log when they start up
  cluster.on('online', (worker) => {
    // Log to file and stdout
    logger.write.worker(`worker ${worker.process.pid} is online`);
  });

  // Gracefully log upon death
  process.on('SIGINT', () => {
    cluster.disconnect();
    logger.write.worker(`master ${process.pid} SIGINT received`);
    process.exit(0);
  });

  // Workers are periodically queried to ensure they are still active.
  // If a worker does not respond after 4 queries, it is killed and a new worker is spawned.
  setInterval(() => {
    eachWorker((worker, id) => {
      if (workerStatus[id] === undefined) {
        workerStatus[id] = -1;
      }

      if (workerStatus[id] < 4) {
        workerStatus[id]++;
        worker.send('check');
      } else {
        delete workerStatus[id];
        // Log to file and stdout
        logger.write.worker(`Problem with worker ${id}`);
        worker.disconnect();
        worker.kill();
      }
    });
  }, params.workerCheckInterval);

  eachWorker((worker, id) => {
    worker.on('message', (msg) => {
      workerStatus[id] = 0;
    });
  });
} else {
  // workers can share any TCP connection

  process.on('message', (msg) => {
    process.send(msg);
  });

  process.on('kill', () => {
    logger.write.worker(`worker${process.pid} killed, shutting down`);
    process.exit(0);
  });

  process.on('SIGINT', () => {
    logger.write.worker(`worker${process.pid} SIGINT received`);
  });

  const app = require('../app');
  const passport = require('../services/passportService');
  // Set up multi-threaded session store and authentication mechanism.
  // Must be in this file for correct implementation with workers
  app.use(session({
    secret: params.cookieSecret,
    name: 'LTSHelpDesk.sid',
    resave: false,
    saveUninitialized: false,
    cookie: { secure: true, httpOnly: true },
    store: cstore.store
  }));
  app.use(passport.initialize());
  app.use(passport.session());

  const server = https.createServer(sslOptions, app)
    .listen(params.httpsPort)
    .on('error', onError)
    .on('listening', () => {
      const addr = server.address();
      const bind = typeof addr === 'string'
        ? `pipe ${addr}`
        : `port ${addr.port}`;
    });
}
